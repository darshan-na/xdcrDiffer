// Copyright (c) 2018 Couchbase, Inc.
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"os/exec"
	"os/signal"
	"reflect"
	"sync"
	"sync/atomic"
	"time"

	"xdcrDiffer/base"
	"xdcrDiffer/dcp"
	"xdcrDiffer/differ"
	fdp "xdcrDiffer/fileDescriptorPool"
	"xdcrDiffer/filterPool"
	"xdcrDiffer/utils"

	"github.com/couchbase/gocb/v2"
	xdcrBase "github.com/couchbase/goxdcr/base"
	xdcrParts "github.com/couchbase/goxdcr/base/filter"
	xdcrLog "github.com/couchbase/goxdcr/log"
	"github.com/couchbase/goxdcr/metadata"
	"github.com/couchbase/goxdcr/metadata_svc"
	"github.com/couchbase/goxdcr/service_def"
	service_def_mock "github.com/couchbase/goxdcr/service_def/mocks"
	"github.com/couchbase/goxdcr/service_impl"
	"github.com/couchbase/goxdcr/streamApiWatcher"
	xdcrUtils "github.com/couchbase/goxdcr/utils"
	"github.com/stretchr/testify/mock"
	"gopkg.in/yaml.v3"
)

var done = make(chan bool)
var configFilePath string
var options struct {
	SourceUrl                         string `yaml:"SourceUrl"`
	SourceUsername                    string `yaml:"SourceUsername"`
	SourcePassword                    string `yaml:"SourcePassword"`
	SourceBucketName                  string `yaml:"SourceBucketName"`
	RemoteClusterName                 string `yaml:"RemoteClusterName"`
	SourceFileDir                     string `yaml:"SourceFileDir"`
	TargetUrl                         string `yaml:"TargetUrl"`
	TargetUsername                    string `yaml:"TargetUsername"`
	TargetPassword                    string `yaml:"TargetPassword"`
	TargetBucketName                  string `yaml:"TargetBucketName"`
	TargetFileDir                     string `yaml:"TargetFileDir"`
	NumberOfSourceDcpClients          uint64 `yaml:"NumberOfSourceDcpClients"`
	NumberOfWorkersPerSourceDcpClient uint64 `yaml:"NumberOfWorkersPerSourceDcpClient"`
	NumberOfTargetDcpClients          uint64 `yaml:"NumberOfTargetDcpClients"`
	NumberOfWorkersPerTargetDcpClient uint64 `yaml:"NumberOfWorkersPerTargetDcpClient"`
	NumberOfWorkersForFileDiffer      uint64 `yaml:"NumberOfWorkersForFileDiffer"`
	NumberOfWorkersForMutationDiffer  uint64 `yaml:"NumberOfWorkersForMutationDiffer"`
	NumberOfBins                      uint64 `yaml:"NumberOfBins"`
	NumberOfFileDesc                  uint64 `yaml:"NumberOfFileDesc"`
	// the duration that the tools should be run, in minutes
	CompleteByDuration uint64 `yaml:"CompleteByDuration"`
	// whether tool should complete after processing all mutations at tool start time
	CompleteBySeqno bool `yaml:"CompleteBySeqno"`
	// directory for checkpoint files
	CheckpointFileDir string `yaml:"CheckpointFileDir"`
	// name of source cluster checkpoint file to load from when tool starts
	// if not specified, source cluster will start from 0
	OldSourceCheckpointFileName string `yaml:"OldSourceCheckpointFileName"`
	// name of target cluster checkpoint file to load from when tool starts
	// if not specified, target cluster will start from 0
	OldTargetCheckpointFileName string `yaml:"OldTargetCheckpointFileName"`
	// name of new checkpoint file to write to when tool shuts down
	// if not specified, tool will not save checkpoint files
	NewCheckpointFileName string `yaml:"NewCheckpointFileName"`
	// directory for storing diffs generated by file differ
	FileDifferDir string `yaml:"FileDifferDir"`
	// output directory for mutation differ
	MutationDifferDir string `yaml:"MutationDifferDir"`
	// size of batch used by mutation differ
	MutationDifferBatchSize uint64 `yaml:"MutationDifferBatchSize"`
	// timeout, in seconds, used by mutation differ
	MutationDifferTimeout uint64 `yaml:"MutationDifferTimeout"`
	// size of source dcp handler channel
	SourceDcpHandlerChanSize uint64 `yaml:"SourceDcpHandlerChanSize"`
	// size of target dcp handler channel
	TargetDcpHandlerChanSize uint64 `yaml:"TargetDcpHandlerChanSize"`
	// timeout for bucket for stats collection, in seconds
	BucketOpTimeout uint64 `yaml:"BucketOpTimeout"`
	// max number of retry for get stats
	MaxNumOfGetStatsRetry uint64 `yaml:"MaxNumOfGetStatsRetry"`
	// max number of retry for send batch
	MaxNumOfSendBatchRetry uint64 `yaml:"MaxNumOfSendBatchRetry"`
	// retry interval for get stats, in seconds
	GetStatsRetryInterval uint64 `yaml:"GetStatsRetryInterval"`
	// retry interval for send batch, in milliseconds
	SendBatchRetryInterval uint64 `yaml:"SendBatchRetryInterval"`
	// max backoff for get stats, in seconds
	GetStatsMaxBackoff uint64 `yaml:"GetStatsMaxBackoff"`
	// max backoff for send batch, in seconds
	SendBatchMaxBackoff uint64 `yaml:"SendBatchMaxBackoff"`
	// delay between source cluster start up and target cluster start up, in seconds
	DelayBetweenSourceAndTarget uint64 `yaml:"DelayBetweenSourceAndTarget"`
	//interval for periodical checkpointing, in seconds
	// value of 0 indicates no periodical checkpointing
	CheckpointInterval uint64 `yaml:"CheckpointInterval"`
	// whether to run data generation
	RunDataGeneration bool `yaml:"RunDataGeneration"`
	// whether to run file differ
	RunFileDiffer bool `yaml:"RunFileDiffer"`
	// whether to verify diff keys through aysnc Get on clusters
	RunMutationDiffer bool `yaml:"RunMutationDiffer"`
	// Whether or not to enforce secure communications for data retrieval
	EnforceTLS bool `yaml:"EnforceTLS"`
	// Number of items kept in memory per binary buffer bucket
	BucketBufferCapacity int `yaml:"BucketBufferCapacity"`
	// Compare metadata, or body, or both
	CompareType string `yaml:"CompareType"`
	// Number of times for mutationsDiffer to retry to resolve doc differences
	MutationDifferRetries int `yaml:"MutationDifferRetries"`
	// Number of secs to wait between retries
	MutationDifferRetriesWaitSecs int `yaml:"MutationDifferRetriesWaitSecs"`
	// Number of filters to be created for the filter pool to be shared
	NumOfFiltersInFilterPool int `yaml:"NumOfFiltersInFilterPool"`
	// Enables DEBUG level logs for xdcrDiffer and gocb verbose logging
	DebugMode bool `yaml:"DebugMode"`
	// a common setup timeout duration - in seconds
	SetupTimeout int `yaml:"SetupTimeout"`
	//string denoting the xattrs that shouldn't be compared
	XattrKeysToBeAvoided []string `yaml:"XattrKeysToBeAvoided"`
}

func argParse() {
	flag.StringVar(&configFilePath, "configPath", "config.yaml",
		"Path to the config file")
}

func yamlParse() error {
	data, err := os.ReadFile("config.yaml")
	if err != nil {
		return fmt.Errorf("error in Reading the Yaml File. err: %v", err)
	}
	err = yaml.Unmarshal(data, &options)
	if err != nil {
		return fmt.Errorf("error unmarshalling YAML: %v", err)
	}
	return validateOptions()
}

func validateOptions() error {
	if options.SourceUsername == "" {
		return fmt.Errorf("missing source username")
	} else if options.SourcePassword == "" {
		return fmt.Errorf("missing source password")
	} else if options.SourceUrl == "" {
		return fmt.Errorf("missing hostname and port")
	} else if options.SourceBucketName == "" {
		return fmt.Errorf("missing sourceBucket")
	} else if options.TargetBucketName == "" {
		return fmt.Errorf("missing targetBucket")
	} else if options.RemoteClusterName == "" && options.TargetUrl == "" {
		return fmt.Errorf("missing remoteCluster name or target URL")
	}
	return nil
}

func validateCompareType(method string) {
	for _, str := range base.MutationDiffCompareType {
		if method == str {
			return
		}
	}
	fmt.Fprintf(os.Stderr, "Invalid CompareType '%v'. Accepted values are %v\n", options.CompareType, base.MutationDiffCompareType)
	os.Exit(1)
}

func usage() {
	fmt.Fprintf(os.Stderr, "Usage : %s [OPTIONS] \n", os.Args[0])
	flag.PrintDefaults()
}

type diffToolStateType int

const (
	StateInitial    diffToolStateType = iota
	StateDcpStarted diffToolStateType = iota
	StateFinal      diffToolStateType = iota
)

type difftoolState struct {
	state diffToolStateType
	mtx   sync.Mutex
}

type xdcrDiffTool struct {
	utils                   xdcrUtils.UtilsIface
	metadataSvc             service_def.MetadataSvc
	remoteClusterSvc        service_def.RemoteClusterSvc
	replicationSpecSvc      service_def.ReplicationSpecSvc
	collectionsManifestsSvc service_def.CollectionsManifestSvc
	bucketTopologySvc       service_def.BucketTopologySvc
	logger                  *xdcrLog.CommonLogger

	xdcrTopologySvc service_def.XDCRCompTopologySvc

	selfRef             *metadata.RemoteClusterReference
	selfRefPopulated    uint32
	specifiedRef        *metadata.RemoteClusterReference
	specifiedSpec       *metadata.ReplicationSpecification
	filter              xdcrParts.Filter
	selfDefaultPoolInfo map[string]interface{}
	selfPoolsNodes      map[string]interface{}

	srcCapabilities  metadata.Capability
	tgtCapabilities  metadata.Capability
	srcClusterCompat int

	srcBucketManifest *metadata.CollectionsManifest
	tgtBucketManifest *metadata.CollectionsManifest

	// If non-empty, just stream these collection IDs from each side's DCP
	srcCollectionIds []uint32
	tgtCollectionIds []uint32
	// Logically there should only be 1-1 mapping, but make this flexible just in case
	srcToTgtColIdsMap map[uint32][]uint32

	// For collections migration mode, each filter should cause one or more target collection IDs
	colFilterToTgtColIdsMap map[string][]uint32
	// Each filter string above is translated into a consistent ordered list below. The *index* of each filter
	// string will then be used for the remainder of the differ protocol, and used to determine if a source mutation
	// has passed a certain filter or not
	colFilterOrderedKeys        []string
	colFilterOrderedTargetNs    []*xdcrBase.CollectionNamespace
	colFilterOrderedTargetColId []uint32

	// Used for migration mapping
	migrationMapping  metadata.CollectionNamespaceMapping
	duplicatedMapping differ.DuplicatedHintMap

	sourceDcpDriver *dcp.DcpDriver
	targetDcpDriver *dcp.DcpDriver

	curState difftoolState

	legacyMode bool
	//Xattr Keys to be excluded for comparison
	xattrKeysForNoCompare map[string]bool
}

func NewDiffTool(legacyMode bool) (*xdcrDiffTool, error) {
	var err error
	difftool := &xdcrDiffTool{
		utils:                   xdcrUtils.NewUtilities(),
		legacyMode:              legacyMode,
		srcToTgtColIdsMap:       make(map[uint32][]uint32),
		colFilterToTgtColIdsMap: map[string][]uint32{},
		xattrKeysForNoCompare:   map[string]bool{},
	}
	// if options.fileContaingXattrKeysForNoComapre != "" {
	// 	readFile, er := os.Open(options.fileContaingXattrKeysForNoComapre)
	// 	if er != nil {
	// 		fmt.Printf("Error in reading the file %v. err=%v\n", options.fileContaingXattrKeysForNoComapre, err)
	// 		return nil, er
	// 	}
	// 	fileScanner := bufio.NewScanner(readFile)
	// 	fileScanner.Split(bufio.ScanLines)
	// 	for fileScanner.Scan() {
	// 		difftool.xattrKeysForNoCompare[fileScanner.Text()] = true
	// 	}
	// }
	difftool.xattrKeysForNoCompare[xdcrBase.XATTR_HLV] = true
	difftool.xattrKeysForNoCompare[xdcrBase.XATTR_IMPORTCAS] = true
	logCtx := xdcrLog.DefaultLoggerContext
	difftool.logger = xdcrLog.NewLogger("xdcrDiffTool", xdcrLog.DefaultLoggerContext)
	if options.DebugMode {
		logCtx.SetLogLevel(xdcrLog.LogLevelDebug)
		gocb.SetLogger(gocb.VerboseStdioLogger())
	}

	difftool.selfRef, _ = metadata.NewRemoteClusterReference("", base.SelfReferenceName, options.SourceUrl, options.SourceUsername, options.SourcePassword,
		"", false, "", nil, nil, nil, nil)

	if !legacyMode {
		difftool.metadataSvc, err = metadata_svc.NewMetaKVMetadataSvc(nil, difftool.utils, true /*readOnly*/)
		if err != nil {
			return nil, err
		}

		uiLogSvcMock := &service_def_mock.UILogSvc{}
		uiLogSvcMock.On("Write", mock.Anything).Run(func(args mock.Arguments) { fmt.Printf("%v", args.Get(0).(string)) }).Return(nil)
		xdcrTopologyMock := &service_def_mock.XDCRCompTopologySvc{}
		xdcrTopologyMockSetupCb := func() {
			setupXdcrToplogyMock(xdcrTopologyMock, difftool)
		}
		resolverSvcMock := &service_def_mock.ResolverSvcIface{}
		checkpointSvcMock := &service_def_mock.CheckpointsService{}
		manifestsSvcMock := &service_def_mock.ManifestsService{}
		manifestsSvcMock.On("GetSourceManifests", mock.Anything).Return(nil, service_def.MetadataNotFoundErr)
		manifestsSvcMock.On("GetTargetManifests", mock.Anything).Return(nil, service_def.MetadataNotFoundErr)

		replicationSettingSvc := metadata_svc.NewReplicationSettingsSvc(difftool.metadataSvc, nil, xdcrTopologyMock)

		difftool.remoteClusterSvc, err = metadata_svc.NewRemoteClusterService(uiLogSvcMock, difftool.metadataSvc, xdcrTopologyMock,
			xdcrLog.DefaultLoggerContext, difftool.utils)
		if err != nil {
			return nil, err
		}

		if err = difftool.retrieveClustersCapabilities(legacyMode, xdcrTopologyMockSetupCb); err != nil {
			return nil, err
		}

		difftool.replicationSpecSvc, err = metadata_svc.NewReplicationSpecService(uiLogSvcMock, difftool.remoteClusterSvc,
			difftool.metadataSvc, xdcrTopologyMock, resolverSvcMock, difftool.logger.LoggerContext(), difftool.utils,
			replicationSettingSvc)
		if err != nil {
			return nil, err
		}

		err = difftool.retrieveReplicationSpecInfo()
		if err != nil {
			return nil, err
		}

		securitySvc := &service_def_mock.SecuritySvc{}
		setupSecuritySvcMock(securitySvc)
		err = setupMyKVNodes(xdcrTopologyMock, difftool)
		if err != nil {
			return nil, err
		}

		difftool.bucketTopologySvc, err = service_impl.NewBucketTopologyService(xdcrTopologyMock, difftool.remoteClusterSvc,
			difftool.utils, xdcrBase.TopologyChangeCheckInterval, difftool.logger.LoggerContext(),
			difftool.replicationSpecSvc, xdcrBase.HealthCheckInterval, securitySvc, streamApiWatcher.GetStreamApiWatcher)
		if err != nil {
			return nil, err
		}
		difftool.collectionsManifestsSvc, err = metadata_svc.NewCollectionsManifestService(difftool.remoteClusterSvc,
			difftool.replicationSpecSvc, uiLogSvcMock, difftool.logger.LoggerContext(), difftool.utils, checkpointSvcMock,
			xdcrTopologyMock, difftool.bucketTopologySvc, manifestsSvcMock)
		if err != nil {
			return nil, err
		}

		difftool.logger.Infof("Source cluster supports collections: %v Target cluster supports collections: %v\n",
			difftool.srcCapabilities.HasCollectionSupport(), difftool.tgtCapabilities.HasCollectionSupport())

		if difftool.srcCapabilities.HasCollectionSupport() || difftool.tgtCapabilities.HasCollectionSupport() {
			err = difftool.populateCollectionsPreReq()
			if err != nil {
				return nil, err
			}
		}
	} else {
		// Need to do this outside of legacy mode
		if err := difftool.retrieveClustersCapabilities(legacyMode, nil); err != nil {
			return nil, err
		}
	}

	// Capture any Ctrl-C for continuing to next steps or cleanup
	go difftool.monitorInterruptSignal()

	return difftool, err
}

func setupSecuritySvcMock(securitySvc *service_def_mock.SecuritySvc) {
	securitySvc.On("IsClusterEncryptionLevelStrict").Return(false)
}

// This may be re-set up once self-reference is populated
func setupXdcrToplogyMock(xdcrTopologyMock *service_def_mock.XDCRCompTopologySvc, diffTool *xdcrDiffTool) {
	xdcrTopologyMock.On("IsMyClusterEnterprise").Return(true, nil)
	xdcrTopologyMock.On("IsKVNode").Return(true, nil)
	xdcrTopologyMock.On("IsMyClusterEncryptionLevelStrict").Return(false)
	xdcrTopologyMock.On("MyClusterCompatibility").Return(diffTool.srcClusterCompat, nil)
	setupTopologyMockCredentials(xdcrTopologyMock, diffTool)
	setupTopologyMockConnectionString(xdcrTopologyMock, diffTool)
}

func setupMyKVNodes(topologyMock *service_def_mock.XDCRCompTopologySvc, diffTool *xdcrDiffTool) error {
	// As of XDCR v8, pools/nodes endpoint is gone so we need to do things the legacy way
	nodesInfo := diffTool.selfPoolsNodes
	if nodes, ok := nodesInfo[base.NodesKey]; !ok {
		return fmt.Errorf("%v is not found from pools/nodes output", base.NodesKey)
	} else if nodesList, ok := nodes.([]interface{}); !ok {
		return fmt.Errorf("nodesList is not an interface list")
	} else {
		var found bool
		for _, node := range nodesList {
			nodeInfoMap, ok := node.(map[string]interface{})
			if !ok {
				// should never get here
				return fmt.Errorf("node type is %v", reflect.TypeOf(node))
			}
			thisNode, ok := nodeInfoMap[xdcrBase.ThisNodeKey]
			if ok {
				thisNodeBool, ok := thisNode.(bool)
				if !ok {
					// should never get here
					return fmt.Errorf("thisNode is %v", reflect.TypeOf(thisNode))
				}
				if thisNodeBool {
					// found current node
					found = true
				}
			}
			if found {
				ports := nodeInfoMap[xdcrBase.PortsKey]
				portsMap := ports.(map[string]interface{})
				directPort := portsMap[xdcrBase.DirectPortKey]
				directPortFloat := directPort.(float64)
				memcachedPort := uint16(directPortFloat)

				hostAddr := nodeInfoMap[xdcrBase.HostNameKey]
				hostAddrStr := hostAddr.(string)

				hostName := xdcrBase.GetHostName(hostAddrStr)
				memcachedAddr := xdcrBase.GetHostAddr(hostName, memcachedPort)
				topologyMock.On("MyKVNodes").Return([]string{memcachedAddr}, nil)
				break
			}
		}
		if !found {
			return fmt.Errorf("Unable to set memcached port")
		}
	}
	return nil
}

func setupTopologyMockConnectionString(xdcrTopologyMock *service_def_mock.XDCRCompTopologySvc, diffTool *xdcrDiffTool) {
	connFunc := func() string {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			connStr, _ := diffTool.selfRef.MyConnectionStr()
			return connStr
		} else {
			return ""
		}
	}

	errFunc := func() error {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return nil
		} else {
			return fmt.Errorf("Not initialized yet")
		}
	}

	xdcrTopologyMock.On("MyConnectionStr").Return(connFunc, errFunc)
}

func setupTopologyMockCredentials(xdcrTopologyMock *service_def_mock.XDCRCompTopologySvc, diffTool *xdcrDiffTool) {
	getUserName := func() string {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.UserName()
		} else {
			return ""
		}
	}
	getPw := func() string {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.Password()
		} else {
			return ""
		}
	}
	getAuthMech := func() xdcrBase.HttpAuthMech {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.HttpAuthMech()
		} else {
			return xdcrBase.HttpAuthMechPlain
		}
	}
	getCert := func() []byte {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.Certificates()
		} else {
			return nil
		}
	}
	getSanCert := func() bool {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.SANInCertificate()
		} else {
			return false
		}
	}
	getClientCert := func() []byte {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.ClientCertificate()
		} else {
			return nil
		}
	}
	getClientKey := func() []byte {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return diffTool.selfRef.ClientKey()
		} else {
			return nil
		}
	}
	getErr := func() error {
		if atomic.LoadUint32(&diffTool.selfRefPopulated) == 1 {
			return nil
		} else {
			return fmt.Errorf("Not initialized yet")
		}
	}
	xdcrTopologyMock.On("MyCredentials").Return(getUserName, getPw, getAuthMech, getCert, getSanCert, getClientCert, getClientKey, getErr)
}

func maybeSetEnv(key, value string) {
	if os.Getenv(key) != "" {
		return
	}
	os.Setenv(key, value)
}

func main() {
	argParse()
	err := yamlParse()
	if err != nil {
		fmt.Printf("error parsing Yaml: %v\n", err)
		os.Exit(1)
	}
	CBAUTH_URL := fmt.Sprintf("http://%s:%s@%s", options.SourceUsername, options.SourcePassword, options.SourceUrl)
	env := "CBAUTH_REVRPC_URL"
	key_value := "export " + env + "=" + CBAUTH_URL
	key_value_bytes := []byte(key_value)
	fo, err1 := os.Create("test.sh")
	if err1 != nil {
		panic(err1)
	}
	_, err2 := fo.Write(key_value_bytes)
	if err2 != nil {
		panic(err2)
	}

	fo1, err3 := os.Create("test2.sh")
	if err3 != nil {
		panic(err3)
	}
	_, err4 := fo1.Write([]byte("source test.sh"))
	if err4 != nil {
		panic(err4)
	}

	// err = os.Setenv(env, CBAUTH_URL)
	cmd := exec.Command("sh", "test2.sh")
	_, err = cmd.Output()
	// fmt.Println("Darshan ", os.Getenv(env))
	if err != nil {
		fmt.Printf("error in setting CBAUTH environment variable: %v\n", err)
		os.Exit(1)
	}
	base.SetupTimeoutSeconds = options.SetupTimeout

	validateCompareType(options.CompareType)

	fmt.Printf("differ is run with options: %+v\n", options)
	legacyMode := len(options.TargetUsername) > 0

	if err = setupDirectories(); err != nil {
		fmt.Printf("Unable to set up directory structure: %v\n", err)
		os.Exit(1)
	}

	difftool, err := NewDiffTool(legacyMode)
	if err != nil {
		fmt.Printf("Error creating difftool: %v\n", err)
		os.Exit(1)
	}

	if options.EnforceTLS {
		// For using certificates, the source cluster must be on a loopback device since we will be retrieving the
		// source cluster's certificate to prevent sniffing
		if !isURLLoopBack(options.SourceUrl) {
			fmt.Printf("EnforceTLS options requires that source addr %v to use loopback device\n", options.SourceUrl)
			os.Exit(1)
		}
	}

	if legacyMode {
		if options.EnforceTLS {
			fmt.Printf("EnforceTLS option is not compatible with legacyMode")
			os.Exit(1)
		}
		// OK to ignore metakv err in manual mode
		if err := difftool.populateTemporarySpecAndRef(); err != nil {
			fmt.Printf("%v\n", err)
			os.Exit(1)
		}
	}
	if options.RunDataGeneration {
		err := difftool.generateDataFiles()
		if err != nil {
			fmt.Printf("Error generating data files. err=%v\n", err)
			os.Exit(1)
		}
	} else {
		fmt.Printf("Skipping  generating data files since it has been disabled\n")
	}

	if options.RunFileDiffer {
		err := difftool.diffDataFiles()
		if err != nil {
			fmt.Printf("Error running file difftool. err=%v\n", err)
			os.Exit(1)
		}
	} else {
		fmt.Printf("Skipping file difftool since it has been disabled\n")
	}

	if options.RunMutationDiffer {
		difftool.RunMutationDiffer()
	} else {
		fmt.Printf("Skipping mutation diff since it has been disabled\n")
	}
}

func isURLLoopBack(url string) bool {
	IPLoopbackCheck := net.ParseIP(xdcrBase.GetHostName(url))
	hostNameIsLocalHost := xdcrBase.GetHostName(url) == "localhost"
	return IPLoopbackCheck.IsLoopback() || hostNameIsLocalHost
}

func setupDirectories() error {
	err := os.MkdirAll(options.SourceFileDir, 0777)
	if err != nil {
		fmt.Printf("Error mkdir SourceFileDir: %v\n", err)
	}
	err = os.MkdirAll(options.TargetFileDir, 0777)
	if err != nil {
		fmt.Printf("Error mkdir TargetFileDir: %v\n", err)
	}
	err = os.MkdirAll(options.CheckpointFileDir, 0777)
	if err != nil {
		// it is ok for checkpoint dir to be existing, since we do not clean it up
		fmt.Printf("Error mkdir CheckpointFileDir: %v\n", err)
	}
	return nil
}

func (difftool *xdcrDiffTool) createFilter() error {
	var ok bool
	var expr string
	expr, ok = difftool.specifiedSpec.Settings.Values[metadata.FilterExpressionKey].(string)
	filterMode := difftool.specifiedSpec.Settings.GetExpDelMode()
	if ok && len(expr) > 0 {
		var filterVersion xdcrBase.FilterVersionType
		if filterVersion, ok = difftool.specifiedSpec.Settings.Values[metadata.FilterVersionKey].(xdcrBase.FilterVersionType); !ok {
			err := fmt.Errorf("Unable to find filter version given filter expression %v\nsettings:%v\n", expr, difftool.specifiedSpec.Settings)
			return err
		}

		if filterVersion == xdcrBase.FilterVersionKeyOnly {
			expr = xdcrBase.UpgradeFilter(expr)
		}
		difftool.logger.Infof("Found filtering expression: %v\n", expr)
	}
	mobileCompat := difftool.specifiedSpec.Settings.GetMobileCompatible()

	filter, err := filterPool.NewFilterPool(options.NumOfFiltersInFilterPool, expr, difftool.utils, filterMode, mobileCompat)
	difftool.filter = filter
	return err
}

func (difftool *xdcrDiffTool) generateDataFiles() error {
	difftool.logger.Infof("GenerateDataFiles routine started\n")
	defer difftool.logger.Infof("GenerateDataFiles routine completed\n")

	if options.CompleteByDuration == 0 && !options.CompleteBySeqno {
		difftool.logger.Infof("CompleteByDuration is required when CompleteBySeqno is false\n")
		os.Exit(1)
	}

	errChan := make(chan error, 1)
	waitGroup := &sync.WaitGroup{}

	var fileDescPool fdp.FdPoolIface
	if options.NumberOfFileDesc > 0 {
		fileDescPool = fdp.NewFileDescriptorPool(int(options.NumberOfFileDesc))
	}

	if err := difftool.createFilter(); err != nil {
		difftool.logger.Errorf("Error creating filter: %v", err.Error())
		os.Exit(1)
	}

	difftool.sourceDcpDriver = startDcpDriver(difftool.logger, base.SourceClusterName, options.SourceUrl, difftool.specifiedSpec.SourceBucketName,
		difftool.selfRef, options.SourceFileDir, options.CheckpointFileDir,
		options.OldSourceCheckpointFileName, options.NewCheckpointFileName, options.NumberOfSourceDcpClients,
		options.NumberOfWorkersPerSourceDcpClient, options.NumberOfBins, options.SourceDcpHandlerChanSize,
		options.BucketOpTimeout, options.MaxNumOfGetStatsRetry, options.GetStatsRetryInterval,
		options.GetStatsMaxBackoff, options.CheckpointInterval, errChan, waitGroup, options.CompleteBySeqno, fileDescPool, difftool.filter,
		difftool.srcCapabilities, difftool.srcCollectionIds, difftool.colFilterOrderedKeys, difftool.utils, options.BucketBufferCapacity,
		difftool.migrationMapping, difftool.specifiedSpec.Settings.GetMobileCompatible(), difftool.specifiedSpec.Settings.GetExpDelMode(), difftool.xattrKeysForNoCompare)

	delayDurationBetweenSourceAndTarget := time.Duration(options.DelayBetweenSourceAndTarget) * time.Second
	difftool.logger.Infof("Waiting for %v before starting target dcp clients\n", delayDurationBetweenSourceAndTarget)
	time.Sleep(delayDurationBetweenSourceAndTarget)

	difftool.logger.Infof("Starting target dcp clients\n")
	difftool.targetDcpDriver = startDcpDriver(difftool.logger, base.TargetClusterName, difftool.specifiedRef.HostName_,
		difftool.specifiedSpec.TargetBucketName, difftool.specifiedRef,
		options.TargetFileDir, options.CheckpointFileDir, options.OldTargetCheckpointFileName, options.NewCheckpointFileName,
		options.NumberOfTargetDcpClients, options.NumberOfWorkersPerTargetDcpClient, options.NumberOfBins, options.TargetDcpHandlerChanSize,
		options.BucketOpTimeout, options.MaxNumOfGetStatsRetry, options.GetStatsRetryInterval, options.GetStatsMaxBackoff,
		options.CheckpointInterval, errChan, waitGroup, options.CompleteBySeqno, fileDescPool, difftool.filter,
		difftool.tgtCapabilities, difftool.tgtCollectionIds, difftool.colFilterOrderedKeys, difftool.utils, options.BucketBufferCapacity,
		difftool.migrationMapping, difftool.specifiedSpec.Settings.GetMobileCompatible(), difftool.specifiedSpec.Settings.GetExpDelMode(), difftool.xattrKeysForNoCompare)

	difftool.curState.mtx.Lock()
	difftool.curState.state = StateDcpStarted
	difftool.curState.mtx.Unlock()

	var err error
	if options.CompleteBySeqno {
		err = difftool.waitForCompletion(difftool.sourceDcpDriver, difftool.targetDcpDriver, errChan, waitGroup)
	} else {
		err = difftool.waitForDuration(difftool.sourceDcpDriver, difftool.targetDcpDriver, errChan, options.CompleteByDuration, delayDurationBetweenSourceAndTarget)
	}

	return err
}

func (difftool *xdcrDiffTool) diffDataFiles() error {
	difftool.logger.Infof("DiffDataFiles routine started\n")
	defer difftool.logger.Infof("DiffDataFiles routine completed\n")

	err := os.RemoveAll(options.FileDifferDir)
	if err != nil {
		difftool.logger.Errorf("Error removing FileDifferDir: %v\n", err)
	}
	err = os.MkdirAll(options.FileDifferDir, 0777)
	if err != nil {
		return fmt.Errorf("Error mkdir FileDifferDir: %v\n", err)
	}

	difftoolDriver := differ.NewDifferDriver(options.SourceFileDir, options.TargetFileDir, options.FileDifferDir,
		base.DiffKeysFileName, difftool.specifiedSpec.SourceBucketUUID, difftool.specifiedSpec.TargetBucketUUID, int(options.NumberOfWorkersForFileDiffer), int(options.NumberOfBins),
		int(options.NumberOfFileDesc), difftool.srcToTgtColIdsMap, difftool.colFilterOrderedKeys, difftool.colFilterOrderedTargetColId, difftool.bucketTopologySvc, difftool.specifiedSpec, difftool.logger)
	err = difftoolDriver.Run()
	if err != nil {
		difftool.logger.Errorf("Error from diffDataFiles = %v\n", err)
	}
	difftoolDriver.MapLock.RLock()
	if difftool.colFilterOrderedKeys == nil {
		difftool.logger.Infof("Source vb to item count map: %v", difftoolDriver.SrcVbItemCntMap)
	}
	difftool.logger.Infof("Target vb to item count map: %v", difftoolDriver.TgtVbItemCntMap)
	difftoolDriver.MapLock.RUnlock()
	if difftool.colFilterOrderedKeys == nil {
		difftool.logger.Infof("Source bucket item count including tombstones is %v (excluding %v filtered mutations)", difftoolDriver.SourceItemCount, difftool.sourceDcpDriver.FilteredCount())
	} else {
		difftool.logger.Infof("Replication is in migration mode from the source bucket")
	}
	difftool.logger.Infof("Target bucket item count including tombstones is %v (excluding %v filtered mutations)", difftoolDriver.TargetItemCount, difftool.targetDcpDriver.FilteredCount())
	if difftool.colFilterOrderedKeys == nil && difftoolDriver.SourceItemCount != difftoolDriver.TargetItemCount {
		difftool.logger.Infof("Here are the vbuckets with different item counts:")
		for vb, c1 := range difftoolDriver.SrcVbItemCntMap {
			c2 := difftoolDriver.TgtVbItemCntMap[vb]
			if c1 != c2 {
				difftool.logger.Infof("vb:%v source count %v, target count %v", vb, c1, c2)
			}
		}
	}
	difftool.duplicatedMapping = difftoolDriver.DuplicatedHint
	return err
}

func (difftool *xdcrDiffTool) RunMutationDiffer() {
	difftool.logger.Infof("RunMutationDiffer started with compareBody=%v\n", options.CompareType)
	defer difftool.logger.Infof("RunMutationDiffer completed\n")

	err := os.RemoveAll(options.MutationDifferDir)
	if err != nil {
		difftool.logger.Errorf("Error removing MutationDifferDir: %v\n", err)
	}
	err = os.MkdirAll(options.MutationDifferDir, 0777)
	if err != nil {
		err = fmt.Errorf("Error mkdir MutationDifferDir: %v\n", err)
		return
	}

	mutationDiffer := differ.NewMutationDiffer(difftool.specifiedSpec.SourceBucketName, difftool.specifiedSpec.SourceBucketUUID,
		difftool.selfRef, difftool.specifiedSpec.TargetBucketName, difftool.specifiedSpec.TargetBucketUUID, difftool.specifiedRef,
		options.FileDifferDir, options.MutationDifferDir, int(options.NumberOfWorkersForMutationDiffer),
		int(options.MutationDifferBatchSize), int(options.MutationDifferTimeout), int(options.MaxNumOfSendBatchRetry),
		time.Duration(options.SendBatchRetryInterval)*time.Millisecond,
		time.Duration(options.SendBatchMaxBackoff)*time.Second, options.CompareType, difftool.logger, difftool.srcToTgtColIdsMap,
		difftool.srcCapabilities, difftool.tgtCapabilities, difftool.utils, options.MutationDifferRetries,
		options.MutationDifferRetriesWaitSecs, difftool.duplicatedMapping)
	err = mutationDiffer.Run()
	if err != nil {
		difftool.logger.Errorf("Error from RunMutationDiffer = %v\n", err)
	}
}

func startDcpDriver(logger *xdcrLog.CommonLogger, name, url, bucketName string, ref *metadata.RemoteClusterReference, fileDir, CheckpointFileDir, oldCheckpointFileName, NewCheckpointFileName string, numberOfDcpClients, numberOfWorkersPerDcpClient, NumberOfBins, dcpHandlerChanSize, BucketOpTimeout, MaxNumOfGetStatsRetry, GetStatsRetryInterval, GetStatsMaxBackoff, CheckpointInterval uint64, errChan chan error, waitGroup *sync.WaitGroup, CompleteBySeqno bool, fdPool fdp.FdPoolIface, filter xdcrParts.Filter, capabilities metadata.Capability, collectionIDs []uint32, colMigrationFilters []string, utils xdcrUtils.UtilsIface, bucketBufferCap int, migrationMapping metadata.CollectionNamespaceMapping, mobileCompat int, expDelMode xdcrBase.FilterExpDelType, xattrKeysForNoCompare map[string]bool) *dcp.DcpDriver {
	waitGroup.Add(1)
	dcpDriver := dcp.NewDcpDriver(logger, name, url, bucketName, ref, fileDir, CheckpointFileDir, oldCheckpointFileName,
		NewCheckpointFileName, int(numberOfDcpClients), int(numberOfWorkersPerDcpClient), int(NumberOfBins),
		int(dcpHandlerChanSize), time.Duration(BucketOpTimeout)*time.Second, int(MaxNumOfGetStatsRetry),
		time.Duration(GetStatsRetryInterval)*time.Second, time.Duration(GetStatsMaxBackoff)*time.Second,
		int(CheckpointInterval), errChan, waitGroup, CompleteBySeqno, fdPool, filter, capabilities, collectionIDs, colMigrationFilters,
		utils, bucketBufferCap, migrationMapping, mobileCompat, expDelMode, xattrKeysForNoCompare)
	// dcp driver startup may take some time. Do it asynchronously
	go startDcpDriverAysnc(dcpDriver, errChan, logger)
	return dcpDriver
}

func startDcpDriverAysnc(dcpDriver *dcp.DcpDriver, errChan chan error, logger *xdcrLog.CommonLogger) {
	err := dcpDriver.Start()
	if err != nil {
		logger.Errorf("Error starting dcp driver %v. err=%v\n", dcpDriver.Name, err)
		utils.AddToErrorChan(errChan, err)
	}
}

func (difftool *xdcrDiffTool) waitForCompletion(sourceDcpDriver, targetDcpDriver *dcp.DcpDriver, errChan chan error, waitGroup *sync.WaitGroup) error {
	doneChan := make(chan bool, 1)
	go utils.WaitForWaitGroup(waitGroup, doneChan)

	select {
	case err := <-errChan:
		difftool.logger.Errorf("Stop diff generation due to error from dcp client %v\n", err)
		err1 := sourceDcpDriver.Stop()
		if err1 != nil {
			difftool.logger.Errorf("Error stopping source dcp client. err=%v\n", err1)
		}
		err1 = targetDcpDriver.Stop()
		if err1 != nil {
			difftool.logger.Errorf("Error stopping target dcp client. err=%v\n", err1)
		}
		return err
	case <-doneChan:
		difftool.logger.Infof("Source cluster and target cluster have completed\n")
		return nil
	}
}

func (difftool *xdcrDiffTool) waitForDuration(sourceDcpDriver, targetDcpDriver *dcp.DcpDriver, errChan chan error, duration uint64, delayDurationBetweenSourceAndTarget time.Duration) (err error) {
	timer := time.NewTimer(time.Duration(duration) * time.Second)

	select {
	case err = <-errChan:
		difftool.logger.Errorf("Stop diff generation due to error from dcp client %v\n", err)
	case <-timer.C:
		difftool.logger.Infof("Stop diff generation after specified processing duration\n")
	}

	err1 := sourceDcpDriver.Stop()
	if err1 != nil {
		difftool.logger.Errorf("Error stopping source dcp client. err=%v\n", err1)
	}

	time.Sleep(delayDurationBetweenSourceAndTarget)

	err1 = targetDcpDriver.Stop()
	if err1 != nil {
		difftool.logger.Errorf("Error stopping target dcp client. err=%v\n", err1)
	}

	return err
}

func (difftool *xdcrDiffTool) retrieveReplicationSpecInfo() error {
	// CBAUTH has already been setup
	var err error
	if options.EnforceTLS && !difftool.specifiedRef.IsHttps() {
		err = fmt.Errorf("EnforceTLS requires that the remote cluster reference %v to use Full-Encryption mode", difftool.specifiedRef.Name())
		difftool.logger.Errorf(err.Error())
		return err
	}

	if options.TargetUsername != "" && options.TargetUsername != difftool.specifiedRef.UserName() && options.TargetPassword != "" && options.TargetPassword != difftool.specifiedRef.Password() {
		err = fmt.Errorf("user-specified username and password is different from that of the credentials from reference %v", difftool.specifiedRef.Name())
		difftool.logger.Errorf(err.Error())
		return err
	}

	specMap, err := difftool.replicationSpecSvc.AllReplicationSpecs()
	if err != nil {
		difftool.logger.Errorf("Error retrieving specs: %v\n", err)
		return err
	}

	for _, spec := range specMap {
		if spec.SourceBucketName == options.SourceBucketName && spec.TargetBucketName == options.TargetBucketName && spec.TargetClusterUUID == difftool.specifiedRef.Uuid() {
			difftool.specifiedSpec = spec
			break
		}
	}

	if difftool.specifiedSpec == nil {
		difftool.logger.Warnf("Unable to find Replication Spec with source %v target %v, attempting to create a temporary one\n", options.SourceBucketName, options.TargetBucketName)
		// Create a dummy spec
		difftool.specifiedSpec, err = metadata.NewReplicationSpecification(options.SourceBucketName, "" /*sourceBucketUUID*/, difftool.specifiedRef.Uuid(), options.TargetBucketName, "" /*targetBucketUUID*/)
		if err != nil {
			difftool.logger.Errorf(err.Error())
		}
		return err
	}

	difftool.logger.Infof("Found Remote Cluster: %v and Replication Spec: %v\n", difftool.specifiedRef.String(), difftool.specifiedSpec.String())
	return nil
}

func (difftool *xdcrDiffTool) populateTemporarySpecAndRef() error {
	var err error
	difftool.specifiedSpec, err = metadata.NewReplicationSpecification(options.SourceBucketName, "", /*sourceBucketUUID*/
		"" /*targetClusterUUID*/, options.TargetBucketName, "" /*targetBucketUUID*/)
	if err != nil {
		return fmt.Errorf("populateTemporarySpecAndRef() - %v", err)
	}

	difftool.specifiedRef, err = metadata.NewRemoteClusterReference("" /*uuid*/, options.RemoteClusterName /*name*/, options.TargetUrl, options.TargetUsername, options.TargetPassword,
		"", false, "", nil, nil, nil, nil)
	if err != nil {
		return fmt.Errorf("populateTemporarySpecAndRef() - %v", err)
	}

	err = difftool.populateSelfRef()
	if err != nil {
		return fmt.Errorf("populateTemporarySpecAndRef() - %v", err)
	}
	return err
}

func (difftool *xdcrDiffTool) monitorInterruptSignal() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	for sig := range c {
		if sig.String() == "interrupt" {
			difftool.curState.mtx.Lock()
			switch difftool.curState.state {
			case StateInitial:
				os.Exit(0)
			case StateDcpStarted:
				difftool.logger.Warnf("Received interrupt. Closing DCP drivers")
				difftool.sourceDcpDriver.Stop()
				difftool.targetDcpDriver.Stop()
				difftool.curState.state = StateFinal
			case StateFinal:
				os.Exit(0)
			}
			difftool.curState.mtx.Unlock()
		}
	}
}

func (difftool *xdcrDiffTool) populateSelfRef() error {
	difftool.selfRef.HttpsHostName_ = options.SourceUrl
	difftool.selfRef.UserName_ = options.SourceUsername
	difftool.selfRef.Password_ = options.SourcePassword
	difftool.selfRef.HttpAuthMech_ = xdcrBase.HttpAuthMechPlain

	// Only grab certificate if on a loopback device
	if difftool.specifiedRef.IsHttps() && isURLLoopBack(options.SourceUrl) {
		cert, err := utils.GetCertificate(difftool.utils, options.SourceUrl, options.SourceUsername,
			options.SourcePassword, xdcrBase.HttpAuthMechPlain)
		if err != nil {
			return err
		}

		internalHttpsHostname, _, err := difftool.utils.HttpsRemoteHostAddr(options.SourceUrl, nil)
		if err != nil {
			return fmt.Errorf("unable to get httpsRemoteHostAddr: %v", err)
		}

		difftool.selfRef.Certificate_ = cert
		refHttpAuthMech, defaultPoolInfo, _, err := difftool.utils.GetSecuritySettingsAndDefaultPoolInfo(options.SourceUrl,
			internalHttpsHostname, difftool.selfRef.UserName(), difftool.selfRef.Password(),
			difftool.selfRef.Certificates(), difftool.selfRef.ClientCertificate(), difftool.selfRef.ClientKey(),
			difftool.selfRef.IsHalfEncryption(), difftool.logger)
		if err != nil {
			return fmt.Errorf("unable to get security settings: %v", err)
		}
		difftool.selfRef.SetHttpAuthMech(refHttpAuthMech)
		difftool.selfDefaultPoolInfo = defaultPoolInfo

		if refHttpAuthMech == xdcrBase.HttpAuthMechHttps {
			// Need to get the secure port and attach it
			internalSSLPort, internalSSLPortErr, _, _ := difftool.utils.GetRemoteSSLPorts(options.SourceUrl, difftool.logger)
			if internalSSLPortErr == nil {
				sslHostString := xdcrBase.GetHostAddr(xdcrBase.GetHostName(options.SourceUrl), internalSSLPort)
				difftool.selfRef.SetHttpsHostName(sslHostString)
				difftool.selfRef.SetActiveHttpsHostName(sslHostString)
				difftool.logger.Infof("Received SSL port to be %v and setting TLS hostname to %v", internalSSLPort, sslHostString)
			}
		}
	}

	poolsNodesPath := "/pools/nodes"
	err, _ := difftool.utils.QueryRestApi(options.SourceUrl, poolsNodesPath, false, xdcrBase.MethodGet, "", nil, 0, &difftool.selfPoolsNodes, nil)
	if err != nil {
		return fmt.Errorf("unable to get pools/nodes information: %v", err)
	}

	// Do this last
	atomic.StoreUint32(&difftool.selfRefPopulated, 1)
	return nil
}

func (difftool *xdcrDiffTool) retrieveClustersCapabilities(legacyMode bool, xdcrCompTopologyMockCb func()) error {
	var err error
	difftool.specifiedRef, err = difftool.remoteClusterSvc.RemoteClusterByRefName(options.RemoteClusterName, true /*refresh*/)
	if err != nil {
		for err != nil && err == metadata_svc.RefreshNotEnabledYet {
			difftool.logger.Infof("Difftool hasn't finished reaching out to remote cluster. Sleeping 5 seconds and retrying...")
			time.Sleep(5 * time.Second)
			difftool.specifiedRef, err = difftool.remoteClusterSvc.RemoteClusterByRefName(options.RemoteClusterName, true /*refresh*/)
		}
		if err != nil {
			difftool.logger.Errorf("Error retrieving remote clusters: %v\n", err)
			return err
		}
	}
	if err = difftool.populateSelfRef(); err != nil {
		return err
	}

	if !legacyMode {
		ref, err := difftool.remoteClusterSvc.RemoteClusterByRefName(difftool.specifiedRef.Name(), false)
		if err != nil {
			return fmt.Errorf("retrieveClusterCapabilities.RemoteClusterByRefName(%v) - %v", difftool.specifiedRef.Name(), err)
		}

		difftool.tgtCapabilities, err = difftool.remoteClusterSvc.GetCapability(ref)
		if err != nil {
			return fmt.Errorf("retrieveClusterCapabilities.GetCapability(%v) - %v", difftool.specifiedRef.Name(), err)
		}
	}

	// Self capabilities
	if atomic.LoadUint32(&difftool.selfRefPopulated) == 0 {
		return fmt.Errorf("SelfRef has not been populated\n")
	}
	connStr, err := difftool.selfRef.MyConnectionStr()
	if err != nil {
		return fmt.Errorf("retrieveClusterCapabilities.myConnStr(%v) - %v", difftool.selfRef.Name(), err)
	}
	defaultPoolInfo, err := difftool.utils.GetClusterInfo(connStr, xdcrBase.DefaultPoolPath, difftool.selfRef.UserName(),
		difftool.selfRef.Password(), difftool.selfRef.HttpAuthMech(), difftool.selfRef.Certificates(),
		difftool.selfRef.SANInCertificate(), difftool.selfRef.ClientCertificate(), difftool.selfRef.ClientKey(),
		difftool.logger)
	if err != nil {
		return fmt.Errorf("retrieveClusterCapabilities.getClusterInfo(%v) - %v", difftool.selfRef.Name(), err)
	}

	err = difftool.srcCapabilities.LoadFromDefaultPoolInfo(defaultPoolInfo, difftool.logger)
	if err != nil {
		return fmt.Errorf("retrieveClusterCapabilities.LoadFromDefaultPoolInfo(%v) - %v", defaultPoolInfo, err)
	} else {
		// At this point, clusterCompat is parsable and just cache it for later mocks
		nodeList, _ := xdcrBase.GetNodeListFromInfoMap(defaultPoolInfo, difftool.logger)
		difftool.srcClusterCompat, _ = xdcrBase.GetClusterCompatibilityFromNodeList(nodeList)
	}

	if xdcrCompTopologyMockCb != nil {
		xdcrCompTopologyMockCb()
	}
	return nil
}

func (difftool *xdcrDiffTool) populateCollectionsPreReq() error {
	if difftool.srcCapabilities.HasCollectionSupport() && difftool.tgtCapabilities.HasCollectionSupport() {
		// Both have collections support
		if err := difftool.PopulateManifestsAndMappings(); err != nil {
			return err
		}
	} else if difftool.srcCapabilities.HasCollectionSupport() && !difftool.tgtCapabilities.HasCollectionSupport() {
		// Source has collections but target does not - stream only default collection from the source
		difftool.srcCollectionIds = append(difftool.srcCollectionIds, 0)
	} else if !difftool.srcCapabilities.HasCollectionSupport() && difftool.tgtCapabilities.HasCollectionSupport() {
		// Source does not have collections but target does - stream only default collection from the target
		difftool.tgtCollectionIds = append(difftool.tgtCollectionIds, 0)
	} else {
		// neither have collections - dont' do anything
	}
	return nil
}

// This is needed whenever source and tgt clusters are >= 7.0
func (difftool *xdcrDiffTool) PopulateManifestsAndMappings() error {
	var err error
	difftool.logger.Infof("Waiting 15 sec for manfiest service to initialize and then getting manifest for source Bucket %v target Bucket %v...\n", difftool.specifiedSpec.SourceBucketName, difftool.specifiedSpec.TargetBucketName)
	time.Sleep(15 * time.Second)

	difftool.srcBucketManifest, difftool.tgtBucketManifest, err = difftool.collectionsManifestsSvc.GetLatestManifests(difftool.specifiedSpec, false)
	if err != nil {
		difftool.logger.Errorf("PopulateManifestsAndMappings() - %v\n", err)
		return err
	}

	difftool.logger.Infof("Source manifest: %v", difftool.srcBucketManifest)
	difftool.logger.Infof("Target manifest: %v", difftool.tgtBucketManifest)
	// Store the manifests in files
	err = difftool.outputManifestsToFiles(err)
	if err != nil {
		return err
	}

	modes := difftool.specifiedSpec.Settings.GetCollectionModes()
	rules := difftool.specifiedSpec.Settings.GetCollectionsRoutingRules()
	if modes.IsMigrationOn() && rules.IsExplicitMigrationRule() {
		difftool.logger.Infof("Replication spec is using special migration mapping")
	} else if modes.IsMigrationOn() {
		difftool.logger.Infof("Replication spec is using migration mode")
	} else if modes.IsExplicitMapping() {
		difftool.logger.Infof("Replication spec is using explicit mapping")
	} else {
		difftool.logger.Infof("Replication spec is using implicit mapping")
	}
	err = difftool.compileCollectionMapping()
	if err != nil {
		return err
	}

	// Once hardcoded compilation map has been generated, just stream these Collection IDs from DCP to minimize other noise
	difftool.generateSrcAndTgtColIds()

	return nil
}

func (difftool *xdcrDiffTool) outputManifestsToFiles(err error) error {
	srcManJson, err := json.Marshal(difftool.srcBucketManifest)
	if err != nil {
		difftool.logger.Errorf("SrcManifestMarshal - %v\n", err)
		return err
	}

	tgtManJson, err := json.Marshal(difftool.tgtBucketManifest)
	if err != nil {
		difftool.logger.Errorf("TgtManifestMarshal - %v\n", err)
		return err
	}

	err = ioutil.WriteFile(utils.GetManifestFileName(options.SourceFileDir), srcManJson, 0644)
	if err != nil {
		difftool.logger.Errorf("SrcManifestWrite - %v\n", err)
		return err
	}

	err = ioutil.WriteFile(utils.GetManifestFileName(options.TargetFileDir), tgtManJson, 0644)
	if err != nil {
		difftool.logger.Errorf("TgtManifestWrite - %v\n", err)
		return err
	}
	return nil
}

func (difftool *xdcrDiffTool) compileCollectionMapping() error {
	pair := metadata.CollectionsManifestPair{
		Source: difftool.srcBucketManifest,
		Target: difftool.tgtBucketManifest,
	}
	namespaceMapping, err := metadata.NewCollectionNamespaceMappingFromRules(pair, difftool.specifiedSpec.Settings.GetCollectionModes(), difftool.specifiedSpec.Settings.GetCollectionsRoutingRules(), false, false)
	if err != nil {
		difftool.logger.Errorf("NewCollectionNamespaceMappingFromRules err: %v", err)
		return err
	}

	modes := difftool.specifiedSpec.Settings.GetCollectionModes()
	rules := difftool.specifiedSpec.Settings.GetCollectionsRoutingRules()
	if modes.IsMigrationOn() && !rules.IsExplicitMigrationRule() {
		return difftool.compileMigrationMapping(namespaceMapping)
	} else {
		difftool.compileHardcodedColToColMapping(namespaceMapping)
	}
	return nil
}

func (difftool *xdcrDiffTool) compileHardcodedColToColMapping(namespaceMapping metadata.CollectionNamespaceMapping) {
	for srcNs, tgtNamespaces := range namespaceMapping {
		for _, tgtNs := range tgtNamespaces {
			scopeName := srcNs.GetCollectionNamespace().ScopeName
			collectionName := srcNs.GetCollectionNamespace().CollectionName
			tgtScopeName := tgtNs.ScopeName
			tgtCollectionName := tgtNs.CollectionName
			srcColId, srcErr := difftool.srcBucketManifest.GetCollectionId(scopeName, collectionName)
			tgtColId, tgtErr := difftool.tgtBucketManifest.GetCollectionId(tgtScopeName, tgtCollectionName)

			if srcErr != nil {
				difftool.logger.Errorf("Cannot find %v - %v from source manifest %v\n", scopeName, collectionName, srcErr)
				continue
			}
			if tgtErr != nil {
				difftool.logger.Errorf("Cannot find %v - %v from target manifest %v\n", scopeName, collectionName, tgtErr)
				continue
			}

			tgtList := []uint32{tgtColId}
			difftool.srcToTgtColIdsMap[srcColId] = tgtList
		}
	}

	difftool.logger.Infof("Collection namespace mapping: %v idsMap: %v", namespaceMapping, difftool.srcToTgtColIdsMap)
}

func (difftool *xdcrDiffTool) generateSrcAndTgtColIds() {
	tgtColIdDedupMap := make(map[uint32]bool)

	modes := difftool.specifiedSpec.Settings.GetCollectionModes()
	rules := difftool.specifiedSpec.Settings.GetCollectionsRoutingRules()
	var migrationMode bool

	if modes.IsMigrationOn() && !rules.IsExplicitMigrationRule() {
		migrationMode = true
		for _, tgtColIds := range difftool.colFilterToTgtColIdsMap {
			difftool.populateDedupColIds(tgtColIds, tgtColIdDedupMap)
		}
	} else {
		for srcColId, tgtColIds := range difftool.srcToTgtColIdsMap {
			if !migrationMode {
				difftool.srcCollectionIds = append(difftool.srcCollectionIds, srcColId)
			}
			difftool.populateDedupColIds(tgtColIds, tgtColIdDedupMap)
		}
	}

	if migrationMode {
		// Migration mode wise we only pull from the source collectionID
		difftool.srcCollectionIds = []uint32{xdcrBase.DefaultCollectionId}
	}
}

func (difftool *xdcrDiffTool) populateDedupColIds(tgtColIds []uint32, tgtColIdDedupMap map[uint32]bool) {
	for _, tgtColId := range tgtColIds {
		_, exists := tgtColIdDedupMap[tgtColId]
		if !exists {
			tgtColIdDedupMap[tgtColId] = true
			difftool.tgtCollectionIds = append(difftool.tgtCollectionIds, tgtColId)
		}
	}
}

func (difftool *xdcrDiffTool) compileMigrationMapping(nsMappings metadata.CollectionNamespaceMapping) error {
	for srcNs, tgtNsList := range nsMappings {
		if len(tgtNsList) > 1 {
			return fmt.Errorf("Migration rules with more than one target namespace is not supported")
		}
		for _, tgtNs := range tgtNsList {
			colId, err := difftool.tgtBucketManifest.GetCollectionId(tgtNs.ScopeName, tgtNs.CollectionName)
			if err != nil {
				difftool.logger.Errorf("Cannot find target namespace in manifest: %v", tgtNs.ToIndexString())
				continue
			}
			if _, exists := difftool.colFilterToTgtColIdsMap[srcNs.String()]; !exists {
				difftool.colFilterToTgtColIdsMap[srcNs.String()] = []uint32{colId}
			} else {
				difftool.colFilterToTgtColIdsMap[srcNs.String()] = append(difftool.colFilterToTgtColIdsMap[srcNs.String()], colId)
			}
			difftool.colFilterOrderedTargetNs = append(difftool.colFilterOrderedTargetNs, tgtNs)
		}
		difftool.colFilterOrderedKeys = append(difftool.colFilterOrderedKeys, srcNs.String())
	}

	difftool.logger.Infof("Collections Migrations filters ordered list:\n")
	for i, filterStr := range difftool.colFilterOrderedKeys {
		difftool.logger.Infof("%v : %v -> %v", i, filterStr, difftool.colFilterOrderedTargetNs[i].ToIndexString())
	}

	// Ensure that the colIdMappings are handled accordingly
	for _, targetNs := range difftool.colFilterOrderedTargetNs {
		targetColId, err := difftool.tgtBucketManifest.GetCollectionId(targetNs.ScopeName, targetNs.CollectionName)
		if err != nil {
			return fmt.Errorf("cannot find collection %v from manifest %v", targetNs.ToIndexString(), difftool.tgtBucketManifest.String())
		}
		difftool.srcToTgtColIdsMap[0] = append(difftool.srcToTgtColIdsMap[0], targetColId)
		difftool.colFilterOrderedTargetColId = append(difftool.colFilterOrderedTargetColId, targetColId)
	}

	// The migrationMapping will be shared among many components, so we need to make sure it is sharable
	return difftool.populateMigrationMapping(nsMappings)
}

func (difftool *xdcrDiffTool) populateMigrationMapping(namespaceMappings metadata.CollectionNamespaceMapping) error {
	difftool.migrationMapping = namespaceMappings.Clone()
	filterMode := difftool.specifiedSpec.Settings.GetExpDelMode()
	mobileCompat := difftool.specifiedSpec.Settings.GetMobileCompatible()
	for srcNamespacePtr, _ := range difftool.migrationMapping {
		// For each sourceNamespace, its filter needs to be a pool
		expr := srcNamespacePtr.GetFilterString()
		pool, err := filterPool.NewFilterPool(options.NumOfFiltersInFilterPool, expr, difftool.utils, filterMode, mobileCompat)
		if err != nil {
			return err
		}
		srcNamespacePtr.ReplaceFilter(pool)
	}
	return nil
}
